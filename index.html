<!doctype html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
Â  <title>SSCWC Chess Crypto Kings</title>
Â  <style>
Â  Â  /* ---- Your original styling mostly preserved ---- */
Â  Â  body {
Â  Â  Â  margin: 0;
Â  Â  Â  font-family: "Poppins", sans-serif;
Â  Â  Â  background: #000;
Â  Â  Â  color: #fff;
Â  Â  Â  text-align: center;
Â  Â  Â  -webkit-font-smoothing: antialiased;
Â  Â  Â  -moz-osx-font-smoothing: grayscale;
Â  Â  }

Â  Â  .logo-container {
Â  Â  Â  margin-top: 40px;
Â  Â  Â  animation: rotateOnce 4s ease-in-out 1, shimmer 3s 4s infinite alternate;
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: center;
Â  Â  Â  align-items: center;
Â  Â  }

Â  Â  .logo-container img {
Â  Â  Â  width: 160px;
Â  Â  Â  border-radius: 50%;
Â  Â  Â  box-shadow: 0 0 60px rgba(255, 215, 0, 0.6);
Â  Â  }

Â  Â  @keyframes rotateOnce {
Â  Â  Â  0% { transform: rotate(0deg); }
Â  Â  Â  100% { transform: rotate(360deg); }
Â  Â  }

Â  Â  @keyframes shimmer {
Â  Â  Â  from { filter: brightness(1) drop-shadow(0 0 15px gold); }
Â  Â  Â  to { filter: brightness(1.4) drop-shadow(0 0 25px #ffd700); }
Â  Â  }

Â  Â  h1 {
Â  Â  Â  font-size: 1.6em;
Â  Â  Â  color: #ffd700;
Â  Â  Â  margin-top: 20px;
Â  Â  }

Â  Â  h2 {
Â  Â  Â  font-size: 1.2em;
Â  Â  Â  font-style: italic;
Â  Â  Â  color: #ffe066;
Â  Â  Â  margin-bottom: 20px;
Â  Â  }

Â  Â  .controls { margin-bottom: 6px; }

Â  Â  .btn {
Â  Â  Â  padding: 12px 18px;
Â  Â  Â  margin: 8px;
Â  Â  Â  border: none;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  font-size: 1em;
Â  Â  Â  font-weight: 600;
Â  Â  Â  transition: transform 0.2s ease, box-shadow 0.2s ease;
Â  Â  }

Â  Â  .btn:hover {
Â  Â  Â  transform: scale(1.05);
Â  Â  Â  box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
Â  Â  }

Â  Â  .btn-pink { background: #ff42e3; color: white; }
Â  Â  .btn-blue { background: #007bff; color: white; }
Â  Â  .btn-green { background: #00b853; color: white; }
Â  Â  .btn-gold {
Â  Â  Â  background: linear-gradient(180deg, #ffea70 0%, #ffcc00 100%);
Â  Â  Â  color: #000;
Â  Â  Â  font-weight: bold;
Â  Â  Â  box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
Â  Â  }

Â  Â  input[type="email"] {
Â  Â  Â  padding: 12px;
Â  Â  Â  width: 280px;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  border: 1px solid #333;
Â  Â  Â  margin: 8px 0;
Â  Â  Â  background: #111;
Â  Â  Â  color: #fff;
Â  Â  Â  text-align: center;
Â  Â  }

Â  Â  #status { color: #ccc; font-size: 0.95rem; margin-top: 6px; }

Â  Â  #chessContainer {
Â  Â  Â  margin: 28px auto;
Â  Â  Â  width: 320px;
Â  Â  Â  height: 320px;
Â  Â  Â  background: radial-gradient(circle at center, #111 60%, #000 100%);
Â  Â  Â  border: 2px solid #ffd700;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  box-shadow: 0 0 40px rgba(255, 215, 0, 0.25);
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: center;
Â  Â  Â  align-items: center;
Â  Â  Â  padding: 10px;
Â  Â  }

Â  Â  #board {
Â  Â  Â  display: grid;
Â  Â  Â  grid-template-columns: repeat(8, 1fr);
Â  Â  Â  grid-template-rows: repeat(8, 1fr);
Â  Â  Â  width: 300px;
Â  Â  Â  height: 300px;
Â  Â  Â  border: 5px solid #ffd700;
Â  Â  Â  box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
Â  Â  Â  position: relative;
Â  Â  Â  user-select: none;
Â  Â  }

Â  Â  .square {
Â  Â  Â  width: 100%;
Â  Â  Â  height: 100%;
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  Â  font-size: 26px;
Â  Â  Â  cursor: pointer;
Â  Â  }

Â  Â  .light { background-color: #f9d98b; }
Â  Â  .dark { background-color: #946b32; }

Â  Â  .white-piece { color: #111; text-shadow: 0 0 6px gold; font-weight: 700; }
Â  Â  .black-piece { color: #000; opacity: 0.95; text-shadow: 0 0 6px #d4af37; }

Â  Â  .highlight { outline: 3px solid rgba(255,255,255,0.25); box-shadow: inset 0 0 8px rgba(255,255,255,0.06); }
Â  Â  .move-dot { width: 10px; height: 10px; border-radius: 50%; background: rgba(0,0,0,0.5); box-shadow: 0 0 6px rgba(0,0,0,0.3); }

Â  Â  footer { margin: 18px 0; color: #777; font-size: 0.9em; }

Â  Â  @media (max-width: 480px) {
Â  Â  Â  #chessContainer { width: 260px; height: 260px; }
Â  Â  Â  #board { width: 240px; height: 240px; }
Â  Â  Â  input[type="email"] { width: 200px; }
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="logo-container">
Â  Â  <img src="https://raw.githubusercontent.com/SSCWealthCoin/sscwealthcoin.github.io/main/Gifcmr3XoAA_WF-.jpeg" alt="SSC Wealth Coin Logo">
Â  </div>

Â  <h1>SSCWC Chess Crypto Kings</h1>
Â  <h2>The Future of Gold on Blockchain</h2>

Â  <input id="emailInput" type="email" placeholder="Your email (for quick sign-in)" />
Â  <div>
Â  Â  <button id="sendLinkBtn" class="btn btn-pink">Send Magic Link</button>
Â  </div>
Â  <div class="controls">
Â  Â  <button id="connectWalletBtn" class="btn btn-blue">Connect Wallet (BSC Testnet)</button>
Â  Â  <button id="createGameBtn" class="btn btn-green">Create Game</button>
Â  Â  <button id="buyBtn" class="btn btn-gold" onclick="window.open('https://app.uniswap.org/explore/tokens/bnb/0xd7deadbf768dec8ac13850e4f6787ac53a9d0447?utm_medium=mobile&utm_source=share-tdp','_blank')">ðŸª™ Buy SSCWC on Uniswap</button>
Â  </div>

Â  <div id="status">Not signed in â€” enter email and click "Send Magic Link"</div>

Â  <div id="chessContainer">
Â  Â  <div id="board" aria-label="Chess board"></div>
Â  </div>

Â  <footer>Â© 2025 SSC Wealth Coin â€” All Rights Reserved</footer>

Â  <!-- Firebase + App Script (module) -->
Â  <script type="module">
Â  Â  /* ------------------ Firebase setup (modular) ------------------ */
Â  Â  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
Â  Â  import { getAuth, sendSignInLinkToEmail, isSignInWithEmailLink, signInWithEmailLink, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

Â  Â  // ---------- Your Firebase config (as provided) ----------
Â  Â  const firebaseConfig = {
Â  Â  Â  apiKey: "AIzaSyCiU4bLmbd5pJ6sv13TAMIk4eh8Exhid4o",
Â  Â  Â  authDomain: "sscwc-chess.firebaseapp.com",
Â  Â  Â  databaseURL: "https://sscwc-chess-default-rtdb.firebaseio.com",
Â  Â  Â  projectId: "sscwc-chess",
Â  Â  Â  storageBucket: "sscwc-chess.firebasestorage.app",
Â  Â  Â  messagingSenderId: "382398698085",
Â  Â  Â  appId: "1:382398698085:web:cc902f0f1b6b1b93602c8c"
Â  Â  };

Â  Â  const app = initializeApp(firebaseConfig);
Â  Â  const auth = getAuth(app);

Â  Â  const emailInput = document.getElementById('emailInput');
Â  Â  const sendLinkBtn = document.getElementById('sendLinkBtn');
Â  Â  const statusEl = document.getElementById('status');

Â  Â  // actionCodeSettings: use current page origin so GitHub Pages will be valid
Â  Â  const actionCodeSettings = {
Â  Â  Â  url: window.location.href,
Â  Â  Â  handleCodeInApp: true,
Â  Â  };

Â  Â  sendLinkBtn.addEventListener('click', async () => {
Â  Â  Â  const email = (emailInput.value || '').trim();
Â  Â  Â  if (!email) { alert('Please enter an email.'); return; }
Â  Â  Â  try {
Â  Â  Â  Â  await sendSignInLinkToEmail(auth, email, actionCodeSettings);
Â  Â  Â  Â  // Save the email locally to complete sign-in after redirect
Â  Â  Â  Â  window.localStorage.setItem('emailForSignIn', email);
Â  Â  Â  Â  alert('Magic link sent! Check your email and follow the link to sign in.');
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  console.error(err);
Â  Â  Â  Â  alert('Error sending magic link: ' + (err.message || err));
Â  Â  Â  }
Â  Â  });

Â  Â  // If this page is opened with an email sign-in link, complete sign-in
Â  Â  window.addEventListener('load', async () => {
Â  Â  Â  try {
Â  Â  Â  Â  if (isSignInWithEmailLink(auth, window.location.href)) {
Â  Â  Â  Â  Â  let email = window.localStorage.getItem('emailForSignIn');
Â  Â  Â  Â  Â  if (!email) {
Â  Â  Â  Â  Â  Â  // Ask user for the email they used previously
Â  Â  Â  Â  Â  Â  email = window.prompt('Please provide the email you used to sign in:');
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (email) {
Â  Â  Â  Â  Â  Â  const result = await signInWithEmailLink(auth, email, window.location.href);
Â  Â  Â  Â  Â  Â  window.localStorage.removeItem('emailForSignIn');
Â  Â  Â  Â  Â  Â  // Clear URL params for neatness (optional)
Â  Â  Â  Â  Â  Â  try { history.replaceState(null, '', window.location.pathname); } catch(e) {}
Â  Â  Â  Â  Â  Â  console.log('Signed in', result.user);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } catch(e) {
Â  Â  Â  Â  console.error('Error completing sign-in', e);
Â  Â  Â  }
Â  Â  });

Â  Â  // Track auth changes
Â  Â  onAuthStateChanged(auth, user => {
Â  Â  Â  if (user) {
Â  Â  Â  Â  statusEl.textContent = 'Signed in as: ' + (user.email || 'anonymous');
Â  Â  Â  Â  statusEl.style.color = '#bdf7b8';
Â  Â  Â  } else {
Â  Â  Â  Â  statusEl.textContent = 'Not signed in â€” enter email and click "Send Magic Link"';
Â  Â  Â  Â  statusEl.style.color = '#ccc';
Â  Â  Â  }
Â  Â  });

Â  Â  /* ------------------ Chess game + AI Level 3 (Minimax depth 3) ------------------ */

Â  Â  // Board representation:
Â  Â  // We'll use an 8x8 array with piece codes:
Â  Â  // White: 'P','R','N','B','Q','K'  | Black: 'p','r','n','b','q','k'
Â  Â  const unicodeMap = {
Â  Â  Â  'P': 'â™™','R':'â™–','N':'â™˜','B':'â™—','Q':'â™•','K':'â™”',
Â  Â  Â  'p': 'â™Ÿ','r':'â™œ','n':'â™ž','b':'â™','q':'â™›','k':'â™š'
Â  Â  };

Â  Â  // Initial board
Â  Â  let boardState = [
Â  Â  Â  ['r','n','b','q','k','b','n','r'],
Â  Â  Â  ['p','p','p','p','p','p','p','p'],
Â  Â  Â  ['','','','','','','',''],
Â  Â  Â  ['','','','','','','',''],
Â  Â  Â  ['','','','','','','',''],
Â  Â  Â  ['','','','','','','',''],
Â  Â  Â  ['P','P','P','P','P','P','P','P'],
Â  Â  Â  ['R','N','B','Q','K','B','N','R']
Â  Â  ];

Â  Â  let whiteToMove = true; // user will play White
Â  Â  let selected = null; // {r,c}
Â  Â  let legalMovesCache = []; // cached legal moves for selected piece

Â  Â  const boardEl = document.getElementById('board');

Â  Â  function coordToIndex(r,c){ return r*8 + c; }
Â  Â  function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

Â  Â  function cloneBoard(b) { return b.map(row => row.slice()); }

Â  Â  // Basic move generator (no castling, no en-passant). Pawn promotion to Queen.
Â  Â  function generateMoves(b, whiteTurn) {
Â  Â  Â  const moves = [];
Â  Â  Â  for (let r=0;r<8;r++){
Â  Â  Â  Â  for (let c=0;c<8;c++){
Â  Â  Â  Â  Â  const p = b[r][c];
Â  Â  Â  Â  Â  if (!p) continue;
Â  Â  Â  Â  Â  const isWhite = (p === p.toUpperCase());
Â  Â  Â  Â  Â  if (isWhite !== whiteTurn) continue;
Â  Â  Â  Â  Â  const piece = p.toLowerCase();
Â  Â  Â  Â  Â  if (piece === 'p') {
Â  Â  Â  Â  Â  Â  const dir = isWhite ? -1 : 1;
Â  Â  Â  Â  Â  Â  const startRow = isWhite ? 6 : 1;
Â  Â  Â  Â  Â  Â  // forward 1
Â  Â  Â  Â  Â  Â  if (inBounds(r+dir,c) && !b[r+dir][c]) {
Â  Â  Â  Â  Â  Â  Â  moves.push({from:[r,c],to:[r+dir,c],promote: (r+dir===0 || r+dir===7)});
Â  Â  Â  Â  Â  Â  Â  // forward 2
Â  Â  Â  Â  Â  Â  Â  if (r === startRow && !b[r+2*dir][c]) moves.push({from:[r,c],to:[r+2*dir,c]});
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // captures
Â  Â  Â  Â  Â  Â  for (const dc of [-1,1]) {
Â  Â  Â  Â  Â  Â  Â  const nr=r+dir, nc=c+dc;
Â  Â  Â  Â  Â  Â  Â  if (inBounds(nr,nc) && b[nr][nc]) {
Â  Â  Â  Â  Â  Â  Â  Â  const occ = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  const occWhite = (occ === occ.toUpperCase());
Â  Â  Â  Â  Â  Â  Â  Â  if (occWhite !== isWhite) moves.push({from:[r,c],to:[nr,nc],capture:true,promote:(nr===0||nr===7)});
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } else if (piece === 'n') {
Â  Â  Â  Â  Â  Â  const del = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
Â  Â  Â  Â  Â  Â  for (const [dr,dc] of del) {
Â  Â  Â  Â  Â  Â  Â  const nr=r+dr, nc=c+dc;
Â  Â  Â  Â  Â  Â  Â  if (!inBounds(nr,nc)) continue;
Â  Â  Â  Â  Â  Â  Â  const occ=b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  if (!occ || (occ && (occ === occ.toUpperCase()) === isWhite ? false : true)) {
Â  Â  Â  Â  Â  Â  Â  Â  moves.push({from:[r,c],to:[nr,nc],capture:!!occ});
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } else if (piece === 'b' || piece === 'r' || piece === 'q') {
Â  Â  Â  Â  Â  Â  const directions = [];
Â  Â  Â  Â  Â  Â  if (piece === 'b' || piece === 'q') directions.push([-1,-1],[-1,1],[1,-1],[1,1]);
Â  Â  Â  Â  Â  Â  if (piece === 'r' || piece === 'q') directions.push([-1,0],[1,0],[0,-1],[0,1]);
Â  Â  Â  Â  Â  Â  for (const [dr,dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  let nr=r+dr, nc=c+dc;
Â  Â  Â  Â  Â  Â  Â  while (inBounds(nr,nc)) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!b[nr][nc]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({from:[r,c],to:[nr,nc]});
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const occ=b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  Â  const occWhite = (occ === occ.toUpperCase());
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (occWhite !== isWhite) moves.push({from:[r,c],to:[nr,nc],capture:true});
Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  nr += dr; nc += dc;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } else if (piece === 'k') {
Â  Â  Â  Â  Â  Â  for (let dr=-1;dr<=1;dr++){
Â  Â  Â  Â  Â  Â  Â  for (let dc=-1;dc<=1;dc++){
Â  Â  Â  Â  Â  Â  Â  Â  if (dr===0 && dc===0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  const nr=r+dr, nc=c+dc;
Â  Â  Â  Â  Â  Â  Â  Â  if (!inBounds(nr,nc)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  const occ=b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (!occ || (occ && (occ === occ.toUpperCase()) === isWhite ? false : true)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({from:[r,c],to:[nr,nc],capture:!!occ});
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  // Filter out moves that leave king in check
Â  Â  Â  const legal = moves.filter(m => {
Â  Â  Â  Â  const nb = cloneBoard(b);
Â  Â  Â  Â  const [fr,fc] = m.from, [tr,tc] = m.to;
Â  Â  Â  Â  let piece = nb[fr][fc];
Â  Â  Â  Â  nb[fr][fc] = '';
Â  Â  Â  Â  // handle promotion
Â  Â  Â  Â  if (m.promote) {
Â  Â  Â  Â  Â  piece = (piece === piece.toUpperCase()) ? 'Q' : 'q';
Â  Â  Â  Â  }
Â  Â  Â  Â  nb[tr][tc] = piece;
Â  Â  Â  Â  return !isKingInCheck(nb, whiteTurn);
Â  Â  Â  });
Â  Â  Â  return legal;
Â  Â  }

Â  Â  function findKing(b, white) {
Â  Â  Â  const target = white ? 'K' : 'k';
Â  Â  Â  for (let r=0;r<8;r++) for (let c=0;c<8;c++) if (b[r][c] === target) return [r,c];
Â  Â  Â  return null;
Â  Â  }

Â  Â  function isSquareAttacked(b, sr, sc, byWhite) {
Â  Â  Â  // generate pseudo-moves for 'byWhite' and see if any target sr,sc
Â  Â  Â  // Simple approach: iterate pieces and see if they can move to sr,sc ignoring checks.
Â  Â  Â  for (let r=0;r<8;r++){
Â  Â  Â  Â  for (let c=0;c<8;c++){
Â  Â  Â  Â  Â  const p=b[r][c]; if(!p) continue;
Â  Â  Â  Â  Â  const isWhite = (p === p.toUpperCase());
Â  Â  Â  Â  Â  if (isWhite !== byWhite) continue;
Â  Â  Â  Â  Â  const piece = p.toLowerCase();
Â  Â  Â  Â  Â  const dr = sr - r, dc = sc - c;
Â  Â  Â  Â  Â  if (piece === 'p') {
Â  Â  Â  Â  Â  Â  const dir = isWhite ? -1 : 1;
Â  Â  Â  Â  Â  Â  if (sr === r + dir && Math.abs(dc) === 1) return true;
Â  Â  Â  Â  Â  } else if (piece === 'n') {
Â  Â  Â  Â  Â  Â  const adx = Math.abs(dr), ady = Math.abs(dc);
Â  Â  Â  Â  Â  Â  if ((adx===1 && ady===2)||(adx===2 && ady===1)) return true;
Â  Â  Â  Â  Â  } else if (piece === 'b' || piece === 'q') {
Â  Â  Â  Â  Â  Â  if (Math.abs(dr) === Math.abs(dc) && dr!==0) {
Â  Â  Â  Â  Â  Â  Â  const stepR = dr/Math.abs(dr), stepC = dc/Math.abs(dc);
Â  Â  Â  Â  Â  Â  Â  let rr = r+stepR, cc = c+stepC, blocked=false;
Â  Â  Â  Â  Â  Â  Â  while (rr !== sr && cc !== sc) {
Â  Â  Â  Â  Â  Â  Â  Â  if (b[rr][cc]) { blocked=true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  rr += stepR; cc += stepC;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  if (!blocked) return true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (piece === 'r' || piece === 'q') {
Â  Â  Â  Â  Â  Â  if ((dr === 0 && dc !== 0) || (dc === 0 && dr !== 0)) {
Â  Â  Â  Â  Â  Â  Â  const stepR = dr === 0 ? 0 : dr/Math.abs(dr);
Â  Â  Â  Â  Â  Â  Â  const stepC = dc === 0 ? 0 : dc/Math.abs(dc);
Â  Â  Â  Â  Â  Â  Â  let rr = r+stepR, cc = c+stepC, blocked=false;
Â  Â  Â  Â  Â  Â  Â  while (rr !== sr || cc !== sc) {
Â  Â  Â  Â  Â  Â  Â  Â  if (b[rr][cc]) { blocked=true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  rr += stepR; cc += stepC;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  if (!blocked) return true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (piece === 'k') {
Â  Â  Â  Â  Â  Â  if (Math.max(Math.abs(dr),Math.abs(dc)) === 1) return true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  function isKingInCheck(b, white) {
Â  Â  Â  const kingPos = findKing(b, white);
Â  Â  Â  if (!kingPos) return true; // no king found => treated as check
Â  Â  Â  const [kr,kc] = kingPos;
Â  Â  Â  return isSquareAttacked(b, kr, kc, !white);
Â  Â  }

Â  Â  // Apply move to board (returns new board)
Â  Â  function applyMove(b, move) {
Â  Â  Â  const nb = cloneBoard(b);
Â  Â  Â  const [fr,fc] = move.from, [tr,tc] = move.to;
Â  Â  Â  let piece = nb[fr][fc];
Â  Â  Â  nb[fr][fc] = '';
Â  Â  Â  if (move.promote) {
Â  Â  Â  Â  piece = (piece === piece.toUpperCase()) ? 'Q' : 'q';
Â  Â  Â  }
Â  Â  Â  nb[tr][tc] = piece;
Â  Â  Â  return nb;
Â  Â  }

Â  Â  // Evaluation: simple material values + small positional tie-breakers
Â  Â  const pieceValue = {'p':100,'n':320,'b':330,'r':500,'q':900,'k':20000};
Â  Â  function evaluate(b) {
Â  Â  Â  let score = 0;
Â  Â  Â  for (let r=0;r<8;r++){
Â  Â  Â  Â  for (let c=0;c<8;c++){
Â  Â  Â  Â  Â  const p = b[r][c];
Â  Â  Â  Â  Â  if (!p) continue;
Â  Â  Â  Â  Â  const isWhite = (p === p.toUpperCase());
Â  Â  Â  Â  Â  const val = pieceValue[p.toLowerCase()] || 0;
Â  Â  Â  Â  Â  score += (isWhite ? 1 : -1) * val;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  // Add small mobility bonus
Â  Â  Â  try {
Â  Â  Â  Â  score += 0.1 * (generateMoves(b, true).length - generateMoves(b, false).length);
Â  Â  Â  } catch(e){}
Â  Â  Â  return score;
Â  Â  }

Â  Â  // Minimax with alpha-beta pruning depth-limited (depth=3 for Level 3)
Â  Â  function minimax(b, depth, alpha, beta, maximizingPlayer) {
Â  Â  Â  const white = maximizingPlayer;
Â  Â  Â  if (depth === 0) {
Â  Â  Â  Â  return {score: evaluate(b), move: null};
Â  Â  Â  }
Â  Â  Â  const moves = generateMoves(b, white);
Â  Â  Â  if (moves.length === 0) {
Â  Â  Â  Â  // checkmate or stalemate
Â  Â  Â  Â  const inCheck = isKingInCheck(b, white);
Â  Â  Â  Â  return {score: inCheck ? (white ? -99999 : 99999) : 0, move: null};
Â  Â  Â  }

Â  Â  Â  let bestMove = null;
Â  Â  Â  if (maximizingPlayer) {
Â  Â  Â  Â  let value = -Infinity;
Â  Â  Â  Â  // simple move ordering: prefer captures first
Â  Â  Â  Â  moves.sort((a,b)=> (b.capture?1:0) - (a.capture?1:0));
Â  Â  Â  Â  for (const m of moves) {
Â  Â  Â  Â  Â  const nb = applyMove(b,m);
Â  Â  Â  Â  Â  const result = minimax(nb, depth-1, alpha, beta, !maximizingPlayer);
Â  Â  Â  Â  Â  if (result.score > value) { value = result.score; bestMove = m; }
Â  Â  Â  Â  Â  alpha = Math.max(alpha, value);
Â  Â  Â  Â  Â  if (alpha >= beta) break;
Â  Â  Â  Â  }
Â  Â  Â  Â  return {score: value, move: bestMove};
Â  Â  Â  } else {
Â  Â  Â  Â  let value = Infinity;
Â  Â  Â  Â  moves.sort((a,b)=> (a.capture?1:0) - (b.capture?1:0));
Â  Â  Â  Â  for (const m of moves) {
Â  Â  Â  Â  Â  const nb = applyMove(b,m);
Â  Â  Â  Â  Â  const result = minimax(nb, depth-1, alpha, beta, !maximizingPlayer);
Â  Â  Â  Â  Â  if (result.score < value) { value = result.score; bestMove = m; }
Â  Â  Â  Â  Â  beta = Math.min(beta, value);
Â  Â  Â  Â  Â  if (alpha >= beta) break;
Â  Â  Â  Â  }
Â  Â  Â  Â  return {score: value, move: bestMove};
Â  Â  Â  }
Â  Â  }

Â  Â  // Public AI function: returns best move for given side, depth=3
Â  Â  function getAIMove(b, whiteSide) {
Â  Â  Â  const d = 3; // level 3
Â  Â  Â  const res = minimax(b, d, -Infinity, Infinity, whiteSide);
Â  Â  Â  return res.move;
Â  Â  }

Â  Â  /* ------------------ UI Rendering + Interaction ------------------ */

Â  Â  function renderBoard() {
Â  Â  Â  boardEl.innerHTML = '';
Â  Â  Â  for (let r=0;r<8;r++){
Â  Â  Â  Â  for (let c=0;c<8;c++){
Â  Â  Â  Â  Â  const sq = document.createElement('div');
Â  Â  Â  Â  Â  sq.className = 'square ' + (((r+c)%2===0) ? 'light' : 'dark');
Â  Â  Â  Â  Â  sq.dataset.r = r; sq.dataset.c = c;
Â  Â  Â  Â  Â  const p = boardState[r][c];
Â  Â  Â  Â  Â  if (p) {
Â  Â  Â  Â  Â  Â  const span = document.createElement('span');
Â  Â  Â  Â  Â  Â  span.textContent = unicodeMap[p] || '';
Â  Â  Â  Â  Â  Â  span.className = (p === p.toUpperCase()) ? 'white-piece' : 'black-piece';
Â  Â  Â  Â  Â  Â  sq.appendChild(span);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  sq.addEventListener('click', onSquareClick);
Â  Â  Â  Â  Â  boardEl.appendChild(sq);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  function clearHighlights() {
Â  Â  Â  Array.from(boardEl.children).forEach(ch => {
Â  Â  Â  Â  ch.classList.remove('highlight');
Â  Â  Â  Â  const dot = ch.querySelector('.move-dot');
Â  Â  Â  Â  if (dot) dot.remove();
Â  Â  Â  });
Â  Â  }

Â  Â  function highlightMoves(moves) {
Â  Â  Â  for (const m of moves) {
Â  Â  Â  Â  const [tr,tc] = m.to;
Â  Â  Â  Â  const idx = coordToIndex(tr,tc);
Â  Â  Â  Â  const cell = boardEl.children[idx];
Â  Â  Â  Â  if (!cell) continue;
Â  Â  Â  Â  cell.classList.add('highlight');
Â  Â  Â  Â  const dot = document.createElement('div');
Â  Â  Â  Â  dot.className = 'move-dot';
Â  Â  Â  Â  cell.appendChild(dot);
Â  Â  Â  }
Â  Â  }

Â  Â  function onSquareClick(e) {
Â  Â  Â  const r = parseInt(this.dataset.r,10);
Â  Â  Â  const c = parseInt(this.dataset.c,10);
Â  Â  Â  const piece = boardState[r][c];

Â  Â  Â  // If a selected piece exists and clicked is one of its legal moves -> move
Â  Â  Â  if (selected) {
Â  Â  Â  Â  const found = legalMovesCache.find(m => m.to[0]===r && m.to[1]===c);
Â  Â  Â  Â  if (found) {
Â  Â  Â  Â  Â  // apply move
Â  Â  Â  Â  Â  boardState = applyMove(boardState, found);
Â  Â  Â  Â  Â  whiteToMove = !whiteToMove;
Â  Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  Â  clearHighlights();
Â  Â  Â  Â  Â  renderBoard();
Â  Â  Â  Â  Â  // If it's now AI's turn, run AI
Â  Â  Â  Â  Â  setTimeout(()=> {
Â  Â  Â  Â  Â  Â  if (!whiteToMove) {
Â  Â  Â  Â  Â  Â  Â  runAIMove();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }, 250);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  // otherwise clear selection if clicking same color piece or empty
Â  Â  Â  Â  selected = null; clearHighlights();
Â  Â  Â  }

Â  Â  Â  // Select a piece if it belongs to the current player (user is white)
Â  Â  Â  if (piece && ((piece === piece.toUpperCase()) === whiteToMove)) {
Â  Â  Â  Â  selected = {r,c};
Â  Â  Â  Â  // compute legal moves for this piece
Â  Â  Â  Â  legalMovesCache = generateMoves(boardState, whiteToMove).filter(m => m.from[0]===r && m.from[1]===c);
Â  Â  Â  Â  clearHighlights();
Â  Â  Â  Â  // highlight origin
Â  Â  Â  Â  this.classList.add('highlight');
Â  Â  Â  Â  highlightMoves(legalMovesCache);
Â  Â  Â  } else {
Â  Â  Â  Â  // clicked empty or enemy piece: ignore / clear
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  clearHighlights();
Â  Â  Â  }
Â  Â  }

Â  Â  async function runAIMove() {
Â  Â  Â  // AI plays Black (whiteToMove false)
Â  Â  Â  statusEl.textContent = 'AI is thinking...';
Â  Â  Â  // Slight delay to simulate 'thinking' and allow UI update
Â  Â  Â  await new Promise(res=>setTimeout(res, 150));
Â  Â  Â  const aiMove = getAIMove(boardState, false);
Â  Â  Â  if (!aiMove) {
Â  Â  Â  Â  // game over or stalemate
Â  Â  Â  Â  const inCheck = isKingInCheck(boardState, !whiteToMove);
Â  Â  Â  Â  statusEl.textContent = inCheck ? 'Checkmate!' : 'Stalemate';
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  boardState = applyMove(boardState, aiMove);
Â  Â  Â  // switch back to user
Â  Â  Â  whiteToMove = !whiteToMove;
Â  Â  Â  renderBoard();
Â  Â  Â  statusEl.textContent = 'Your move';
Â  Â  }

Â  Â  // initial render
Â  Â  renderBoard();
Â  Â  statusEl.textContent = 'Your move â€” play White.';

Â  Â  /* Optional: wire up wallet/connect/createGame buttons as placeholders */
Â  Â  document.getElementById('connectWalletBtn').addEventListener('click', ()=> alert('Wallet connect placeholder (implement Web3 flow here).'));
Â  Â  document.getElementById('createGameBtn').addEventListener('click', ()=> alert('Create game placeholder (matchmaking / on-chain game setup goes here).'));

Â  </script>
</body>
</html>
