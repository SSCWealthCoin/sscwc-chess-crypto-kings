<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SSCWC Chess Crypto Kings</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: "Poppins", Arial, sans-serif;
      text-align: center;
      overflow-x: hidden;
    }
    h1 {
      font-size: 1.8em;
      color: gold;
      letter-spacing: 1px;
      margin: 10px 0 0;
    }
    h2.slogan {
      font-style: italic;
      color: #ffd700;
      font-weight: 400;
      margin-top: -5px;
      margin-bottom: 10px;
    }

    /* Top banner area (coin sits here) */
    #top3D {
      width: 100%;
      height: 200px;
      position: relative;
      background: radial-gradient(circle at center, #000 40%, #111 100%);
      overflow: hidden;
    }

    /* soft pulsing gold shimmer behind the coin (only behind coin) */
    #shimmer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at 50% 40%, rgba(255,215,0,0.28), transparent 30%);
      filter: blur(40px);
      z-index: 1;
      animation: shimmer 6s ease-in-out infinite alternate;
    }
    @keyframes shimmer {
      0% { transform: scale(1) translateY(-4px); opacity: 0.6; }
      100% { transform: scale(1.02) translateY(4px); opacity: 0.95; }
    }

    #threeContainer {
      position: relative;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    /* Buttons / controls - preserved from original */
    a.uniswap-btn, button {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin: 6px;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    a.uniswap-btn {
      background-color: #ff4fd8;
      color: white;
      text-decoration: none;
      display: inline-block;
    }
    button#connect { background: #0099ff; color: white; }
    button#createBtn { background: #29a745; color: white; }
    button#joinBtn { background: #ffc107; color: black; }
    a.uniswap-btn:hover, button:hover { transform: scale(1.03); box-shadow: 0 0 12px gold; }

    #controls {
      margin: 12px auto;
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }

    #joinInput {
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #555;
      background: #111;
      color: #fff;
    }

    /* Chessboard container (unchanged) */
    #chessContainer {
      width: 100%;
      height: 75vh;
      margin-top: 20px;
      border: 2px solid gold;
      box-shadow: 0 0 25px gold;
    }

    /* small helper so three.js canvas sits exactly where we want */
    #threeContainer canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>

  <div id="top3D">
    <div id="shimmer"></div>
    <div id="threeContainer"></div>
  </div>

  <h1>SSCWC Chess Crypto Kings</h1>
  <h2 class="slogan">The Future of Gold on Blockchain</h2>

  <a href="https://app.uniswap.org/explore/tokens/bnb/0xd7deadbf768dec8ac13850e4f6787ac53a9d0447"
     target="_blank" rel="noopener noreferrer" class="uniswap-btn">ðŸ’Ž Get SSCWC on Uniswap</a>
  <button id="connect">Connect Wallet (BSC Testnet)</button>

  <div id="controls">
    <button id="createBtn">Create Game</button>
    <div style="display:flex;gap:6px;align-items:center;">
      <input id="joinInput" placeholder="Paste Game ID" />
      <button id="joinBtn">Join</button>
    </div>
  </div>

  <div id="chessContainer"></div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

  <script>
  (function(){
    // --- setup --- 
    const container = document.getElementById('threeContainer');
    const scene = new THREE.Scene();

    // camera sized to container aspect
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 0.5, 4.5);   // slightly above coin center so king sits nicely
    camera.lookAt(0, 0.3, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // --- lighting ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemi);

    // warm key light above
    const key = new THREE.PointLight(0xffea9b, 2.2, 40, 2);
    key.position.set(0, 5, 6);
    scene.add(key);

    // rim/backlight to separate silhouette
    const rim = new THREE.PointLight(0xffd36b, 0.9, 40, 2);
    rim.position.set(0, -3, -6);
    scene.add(rim);

    // --- materials ---
    const goldMat = new THREE.MeshPhysicalMaterial({
      color: 0xffd32a,
      metalness: 1.0,
      roughness: 0.12,
      clearcoat: 0.8,
      clearcoatRoughness: 0.1,
      emissive: 0x221000,
      emissiveIntensity: 0.25
    });

    const coinEdgeMat = new THREE.MeshStandardMaterial({
      color: 0xd99e00,
      metalness: 1,
      roughness: 0.08
    });

    const silverMat = new THREE.MeshPhysicalMaterial({
      color: 0xdfe7ea,
      metalness: 1,
      roughness: 0.18
    });

    // --- draw a coin face on a canvas to use as a texture (Bitcoin symbol) ---
    function makeCoinFaceTexture(size = 1024) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // background circle (gold gradient)
      const g = ctx.createRadialGradient(size*0.35, size*0.3, size*0.1, size*0.5, size*0.6, size*0.6);
      g.addColorStop(0, '#ffd64d');
      g.addColorStop(1, '#c88600');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size*0.44, 0, Math.PI*2);
      ctx.fill();

      // inner rim (darker)
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.beginPath();
      ctx.arc(size/2, size/2, size*0.36, 0, Math.PI*2);
      ctx.fill();

      // bright outer rim stroke
      ctx.lineWidth = Math.max(6, size*0.02);
      ctx.strokeStyle = '#ffd85a';
      ctx.beginPath();
      ctx.arc(size/2, size/2, size*0.44, 0, Math.PI*2);
      ctx.stroke();

      // Draw a Bitcoin-like 'â‚¿' glyph centered.
      // Fallback: if the browser font doesn't have â‚¿, draw a stylised B with two small vertical strokes.
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // try the real â‚¿ - choose a large font that most platforms support
      const fontSize = Math.floor(size*0.34);
      ctx.font = `bold ${fontSize}px Arial, Helvetica, sans-serif`;
      // measure - fallback if glyph missing (width small)
      const measure = ctx.measureText('â‚¿');
      if (measure.width < fontSize*0.35) {
        // fallback draw stylized B + double stroke:
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${Math.floor(size*0.32)}px Arial`;
        ctx.fillText('B', size/2, size/2 - size*0.02);

        // add vertical strokes (two lines) to emulate â‚¿
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = Math.max(6, size*0.02);
        const x = size/2 + size*0.12;
        ctx.beginPath();
        ctx.moveTo(x, size*0.22);
        ctx.lineTo(x, size*0.78);
        ctx.stroke();
        const x2 = size/2 - size*0.12;
        ctx.beginPath();
        ctx.moveTo(x2, size*0.22);
        ctx.lineTo(x2, size*0.78);
        ctx.stroke();
      } else {
        // draw the unicode character
        ctx.fillStyle = '#fff';
        ctx.fillText('â‚¿', size/2, size/2);
      }

      // small highlight circle to make it look embossed
      ctx.globalCompositeOperation = 'soft-light';
      const hg = ctx.createRadialGradient(size*0.5, size*0.35, size*0.02, size*0.5, size*0.35, size*0.6);
      hg.addColorStop(0, 'rgba(255,255,255,0.25)');
      hg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = hg;
      ctx.beginPath();
      ctx.arc(size/2, size/2 - size*0.12, size*0.3, 0, Math.PI*2);
      ctx.fill();

      // return texture
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const faceTexture = makeCoinFaceTexture(1024);

    // --- build coin: main cylinder + face plane so texture sits perfectly on coin face ---
    const coinRadius = 1.05;
    const coinThickness = 0.18;
    const coinBody = new THREE.Mesh(new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 128, 1), coinEdgeMat);
    // make top and bottom slightly reflective gold by using same goldMat for caps:
    // Three's CylinderGeometry uses same material for whole mesh; easiest is to create three meshes:
    const coinEdge = new THREE.Mesh(new THREE.CylinderGeometry(coinRadius*0.985, coinRadius*0.985, coinThickness, 64), coinEdgeMat);
    // front face (slightly above to avoid z-fighting)
    const faceGeometry = new THREE.CircleGeometry(coinRadius*0.94, 64);
    const faceMaterial = new THREE.MeshStandardMaterial({ map: faceTexture, metalness: 0.9, roughness: 0.12 });
    const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
    faceMesh.rotation.x = -Math.PI/2;
    faceMesh.position.z = coinThickness/2 + 0.001; // sits on top

    // back face (mirror look)
    const backFace = new THREE.Mesh(faceGeometry, new THREE.MeshStandardMaterial({ color: 0xcc9900, metalness: 1, roughness: 0.14 }));
    backFace.rotation.x = Math.PI/2;
    backFace.position.z = -coinThickness/2 - 0.001;

    // Combine coin pieces
    const coinGroup = new THREE.Group();
    coinGroup.add(coinEdge, faceMesh, backFace);

    // Add a subtle golden rim line (thin torus) around coin edge for accent
    const rimTorus = new THREE.Mesh(new THREE.TorusGeometry(coinRadius*0.95, 0.03, 16, 160), goldMat);
    rimTorus.rotation.x = Math.PI / 2;
    rimTorus.position.z = coinThickness/2 + 0.002;
    coinGroup.add(rimTorus);

    // --- build a simple "sculpted" chess king (stacked shapes) and place on coin ---
    const king = new THREE.Group();
    const kingBase = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 0.12, 32), goldMat);
    const kingMid = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.2, 0.42, 32), silverMat);
    const kingNeck = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.18, 32), goldMat);
    const kingCrown = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.03, 16, 64), goldMat);
    kingCrown.rotation.x = Math.PI / 2;
    const kingCross = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.12, 0.03), goldMat);
    kingCross.position.y = 0.7;

    kingBase.position.y = 0;
    kingMid.position.y = 0.28;
    kingNeck.position.y = 0.6;
    kingCrown.position.y = 0.78;

    king.add(kingBase, kingMid, kingNeck, kingCrown, kingCross);

    // position king on top of coin
    king.position.y = coinThickness/2 + 0.12;
    king.position.x = 0;
    king.position.z = 0;

    // add coin and king to a container so they rotate together
    const topGroup = new THREE.Group();
    topGroup.add(coinGroup);
    topGroup.add(king);

    scene.add(topGroup);

    // small ground/soft reflection using a radial gradient plane with very low opacity
    const groundGeo = new THREE.PlaneGeometry(8, 6, 1, 1);
    const groundMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -1.2;
    scene.add(ground);

    // initial scale & position so it looks like your screenshot (coin centered above title)
    topGroup.scale.set(1.0, 1.0, 1.0);
    topGroup.position.set(0, -0.15, 0);

    // --- ensure upright moon-like rotation: rotate about local Y axis only ---
    const rotationSpeed = 0.018; // medium speed (tweak to taste)

    // render loop
    function animate() {
      requestAnimationFrame(animate);
      // upright spin
      topGroup.rotation.y += rotationSpeed;
      renderer.render(scene, camera);
    }
    animate();

    // handle resize
    window.addEventListener('resize', () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    // done
  })();
  </script>
</body>
</html>
